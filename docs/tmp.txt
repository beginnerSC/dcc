#include <iostream>
#include <ranges>
#include <algorithm>

int main()
{
    auto reciprocals_view = std::views::iota(1, 1000) | std::views::transform([](double a){ return 1.0/a; });

    double sum = std::ranges::fold_left(reciprocals_view, 0, std::plus<double>());  // requires c++23

    std::cout << sum << std::endl;
    
    return 0;
}

==============================================

#include <ranges>
#include <set>
#include <initializer_list>

// The original generic function
auto to_set(std::ranges::input_range auto&& r) {
    return std::forward<decltype(r)>(r) | std::ranges::to<std::set>();
}

// Overload to handle {1, 2, 3} syntax
template<typename T>
auto to_set(std::initializer_list<T> il) {
    return to_set(std::views::all(il));
}

int main() {
    auto mySet = to_set({1, 2, 3}); // Now this works perfectly!
}

=============================================

#include <typeinfo>

if (typeid(*a) == typeid(Dog)) {
    // True only if 'a' is exactly a Dog, not a subclass of Dog, but python isinstance does NOT perform exact type match
}

===============================================

与你之前问的 auto&&（万能引用）的区别
这点非常重要，容易混淆：
void SetValue(int&& value)：这是右值引用，只能接右值。
template<typename T> void SetValue(T&& value)：这是万能引用 (Forwarding Reference)。如果你传 i（左值），T 会被推导为 int&；如果你传 10（右值），T 会被推导为 int。
你的笔记展示的是第一种情况（具体的 int&&），所以它的限制是正确的。

#include <type_traits>

template <typename T>
bool is_instance_of_animal(T&& obj) {
    // decay_t removes & and const so the comparison is clean
    return std::is_base_of_v<Animal, std::decay_t<T>>;
}

2. Can the "correct version" take an lvalue?
Yes, it can. In fact, it is designed to take both lvalues and rvalues.
The syntax T&& in a template is called a Forwarding Reference (or Universal Reference).
If you pass an lvalue (a named variable), T is deduced as a reference (e.g., Dog&), and the function works.
If you pass an rvalue (a temporary), T is deduced as the object type (e.g., Dog).
This is why I included std::decay_t<T>. If you pass an lvalue, T becomes Dog&. std::is_base_of cannot process references directly, so decay_t strips the & to turn it back into Dog so the check can happen.


but this will still break case b:

Animal* a = new Dog();
is_instance_of_animal(*a); // Returns FALSE! 
// (T is deduced as 'Animal', and Animal is not a base of Animal in some contexts, 
// or more accurately, it doesn't know it's a Dog).

because you are trying to detect a runtime relationship.
In C++, if you have an Animal* ptr = new Dog();, the compile-time type of *ptr is Animal. Because std::is_base_of_v works strictly at compile-time, it only looks at the "label" on the pointer, not the "actual object" in memory.
Python: isinstance(ptr, Dog) looks at the object in memory (Runtime).
C++ (is_base_of): Looks at the variable declaration (Compile-time).
If your base class has no virtual functions, it is impossible in standard C++ to detect that ptr is a Dog once it has been cast to an Animal*.


======================================


#include <iostream>
#include <type_traits>
#include <string>

// A universal "Type Tag"
template <typename T>
struct Type {};

// Generic isinstance function
template <typename Obj, typename Target>
bool isinstance(Obj&& obj, Type<Target>) {
    // std::decay_t removes const, &, and volatile for a clean comparison
    return std::is_same_v<std::decay_t<Obj>, Target>;
}

int main() {
    int a = 5;
    double b = 3.14;
    std::string s = "hello";

    // Now it works for any type!
    std::cout << std::boolalpha;
    std::cout << isinstance(a, Type<int>{}) << "\n";     // true
    std::cout << isinstance(b, Type<double>{}) << "\n";  // true
    std::cout << isinstance(s, Type<int>{}) << "\n";     // false
}

// C++20 Template Abbreviations 
// Define global constants for convenience
template<typename T> inline constexpr Type<T> IS;

int main() {
    int a = 10;
    // Extremely clean syntax
    if (isinstance(a, IS<int>)) { 
        /* ... */ 
    }
}


template <typename Obj, typename TargetBase>
bool isinstance(Obj&& obj, Type<TargetBase>) {
    // Returns true if TargetBase is a base of the object's type
    return std::is_base_of_v<TargetBase, std::decay_t<Obj>>;
}

====================================

delete Vector::iterator::GetPtr()

Same-Class Access: In C++, an instance of a class can access the private members of any other instance of that same class

====================================

#include <utility>

std::swap(a, b);

// std::swap is optimized with std::move:

template <typename T>
void swap(T& a, T& b) {
    T temp = std::move(a); // Transfers resources from 'a' to 'temp'
    a = std::move(b);      // Transfers resources from 'b' to 'a'
    b = std::move(temp);   // Transfers resources from 'temp' to 'b'
}

// a more python way is

#include <tuple>

int a = 1, b = 2;
std::tie(a, b) = std::make_pair(b, a); 

// std::tie creates a tuple of references to your existing variables. this will work but no one does that. swap is one example c++ code will naturally be different from python




